{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Loafang An easier more readable version of graphql with small learning curve Documentation : https://Adwaith-Rajesh.github.io/loafang Source Code : https://github.com/Adwaith-Rajesh/loafang Loafang is simple, easier more readable alternative for graphql. Some for the key features. Intuitive : The query style used by loafang is easy to read, and gives the user a complete picture on what an execution block does and also on the all the queries in the execution block. Easy : Designed to be easy to use and learn. Less time reading docs. And more on the way Requirements Python 3.7.1 + (Loafang makes a great of dataclasses which is not supported in python3.6 by default) Loafang currently does not require any external dependency to function. Installation pip3 install loafang","title":"Loafang"},{"location":"#loafang","text":"","title":"Loafang"},{"location":"#requirements","text":"Python 3.7.1 + (Loafang makes a great of dataclasses which is not supported in python3.6 by default) Loafang currently does not require any external dependency to function.","title":"Requirements"},{"location":"#installation","text":"pip3 install loafang","title":"Installation"},{"location":"example-usecase/","text":"I cannot find a way to explain each part of the parsing process as each thing is interdependent and you cannot talk about one thing without talking about the other. So here we will go through an example of using loafang with fastapi and tinydb Let's write the code first and then we can talk about what each part does. Installation pip3 install loafang fastapi uvicorn tinydb Let's write some code # app.py from argparse import Namespace # for type hinting purposes only from typing import Any , Dict , List , Union from fastapi import FastAPI , HTTPException from loafang import parse , Methods , MethodsError , QueryBuilder from tinydb import TinyDB , Query query_parser = QueryBuilder ( \"database\" ) query_parser . add_argument ( \"name\" , type = str ) class RequestMethods ( Methods ): def __init__ ( self ) -> None : self . get_query_parser = query_parser self . post_query_parser = query_parser # you can have different parsers # for different request methods # handle the GET request def get ( self , args : Namespace , contents : List [ str ]) -> Any : if not all ( i in [ \"username\" , \"email\" ] for i in contents ): raise MethodsError ( 400 , \"invalid request contents\" ) # raise MethodsError when ever you see that something is not right # with the query that you received User = Query () db = TinyDB ( args . database ) # assumes that the user is in the db rd = db . search ( User . name == args . name )[ 0 ] rv = {} for c in contents : rv [ c ] = rd [ c ] return rv # handle the post request def post ( self , args : Namespace , contents : Dict [ str , Any ]) -> Any : db = TinyDB ( args . database ) db . insert ({ \"username\" : contents [ \"username\" ], \"name\" : args . name , \"email\" : contents [ \"email\" ]}) return { \"msg\" : \"user added successfully\" } # initialize the server app = FastAPI () # vague type of the query the endpoint might receive JSONObject = Union [ Dict [ str , Any ], List [ str ]] req_methods = RequestMethods () @app . get ( \"/\" ) def read_root (): return { \"ping\" : \"pong\" } @app . post ( \"/loaf\" ) def loaf_req ( data : JSONObject ): rd , err , msg = parse ( req_methods , data ) # if something goes whether internally or MethodsError the data returned # will be none and the subsequent code and msg will be provided. # There are no codes for success. return rd if rd else HTTPException ( err , msg ) Let's run the server uvicorn app:app Now let's send a simple post request { \"POST:add-johnny\" : { \"test2.json --name john | add_user_johnny\" : { \"username\" : \"johnny\" , \"email\" : \"johnny@example.com\" } } } With the current way its setup we will get the following response. Let's send a request that will cause MethodsError defined in get will be raised. Inorder to do that we just need to send a GET request with an invalid content. { \"GET:get-johnny\" : { \"test2.json --name john\" : [ \"email\" , \"phone\" ] } } Here phone is not a valid content argument. So we will get following response. So, that's a simple example use case of loafang. If you have any issues feel free to ask it one the discord server, (link in the footer). Or via github issues. Happy Coding.","title":"Example Use case"},{"location":"example-usecase/#installation","text":"pip3 install loafang fastapi uvicorn tinydb","title":"Installation"},{"location":"example-usecase/#lets-write-some-code","text":"# app.py from argparse import Namespace # for type hinting purposes only from typing import Any , Dict , List , Union from fastapi import FastAPI , HTTPException from loafang import parse , Methods , MethodsError , QueryBuilder from tinydb import TinyDB , Query query_parser = QueryBuilder ( \"database\" ) query_parser . add_argument ( \"name\" , type = str ) class RequestMethods ( Methods ): def __init__ ( self ) -> None : self . get_query_parser = query_parser self . post_query_parser = query_parser # you can have different parsers # for different request methods # handle the GET request def get ( self , args : Namespace , contents : List [ str ]) -> Any : if not all ( i in [ \"username\" , \"email\" ] for i in contents ): raise MethodsError ( 400 , \"invalid request contents\" ) # raise MethodsError when ever you see that something is not right # with the query that you received User = Query () db = TinyDB ( args . database ) # assumes that the user is in the db rd = db . search ( User . name == args . name )[ 0 ] rv = {} for c in contents : rv [ c ] = rd [ c ] return rv # handle the post request def post ( self , args : Namespace , contents : Dict [ str , Any ]) -> Any : db = TinyDB ( args . database ) db . insert ({ \"username\" : contents [ \"username\" ], \"name\" : args . name , \"email\" : contents [ \"email\" ]}) return { \"msg\" : \"user added successfully\" } # initialize the server app = FastAPI () # vague type of the query the endpoint might receive JSONObject = Union [ Dict [ str , Any ], List [ str ]] req_methods = RequestMethods () @app . get ( \"/\" ) def read_root (): return { \"ping\" : \"pong\" } @app . post ( \"/loaf\" ) def loaf_req ( data : JSONObject ): rd , err , msg = parse ( req_methods , data ) # if something goes whether internally or MethodsError the data returned # will be none and the subsequent code and msg will be provided. # There are no codes for success. return rd if rd else HTTPException ( err , msg ) Let's run the server uvicorn app:app Now let's send a simple post request { \"POST:add-johnny\" : { \"test2.json --name john | add_user_johnny\" : { \"username\" : \"johnny\" , \"email\" : \"johnny@example.com\" } } } With the current way its setup we will get the following response. Let's send a request that will cause MethodsError defined in get will be raised. Inorder to do that we just need to send a GET request with an invalid content. { \"GET:get-johnny\" : { \"test2.json --name john\" : [ \"email\" , \"phone\" ] } } Here phone is not a valid content argument. So we will get following response. So, that's a simple example use case of loafang. If you have any issues feel free to ask it one the discord server, (link in the footer). Or via github issues. Happy Coding.","title":"Let's write some code"},{"location":"exist_codes/","text":"codes are only for errors 600 -> Something went Wrong 601 -> The header cannot be empty 602 -> Unrecognized method 603 -> Unrecognized property key 604 -> Missing ID 605 -> Invalid Data Type for arguments in the query 606 -> Invalid Data Type for the content container for the query eg: Get, Delete, must have a list as its content container eg: All the other methods must have dict as their content container. 607 -> Parser does not exists for the given request method 608 -> Two Execution Blocks cannot have the same ID's 609 -> The after key must be a string 610 -> The Execution block with the given ID does not exists 611 -> Methods is not implemented 612 -> Execution bock with pe property key cannot have an after key 613 -> Two queries in a block cannot have the same aliases 614 -> Methods Class faced an error","title":"Exist codes"},{"location":"exist_codes/#codes-are-only-for-errors","text":"600 -> Something went Wrong 601 -> The header cannot be empty 602 -> Unrecognized method 603 -> Unrecognized property key 604 -> Missing ID 605 -> Invalid Data Type for arguments in the query 606 -> Invalid Data Type for the content container for the query eg: Get, Delete, must have a list as its content container eg: All the other methods must have dict as their content container. 607 -> Parser does not exists for the given request method 608 -> Two Execution Blocks cannot have the same ID's 609 -> The after key must be a string 610 -> The Execution block with the given ID does not exists 611 -> Methods is not implemented 612 -> Execution bock with pe property key cannot have an after key 613 -> Two queries in a block cannot have the same aliases 614 -> Methods Class faced an error","title":"codes are only for errors"},{"location":"loafang-response/","text":"In this section we will be discussing on what a loafang response looks like. For both an aliased and non aliased queries. Without alias A sample query { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , ] }, \"PUT:update-user-john\" : { \"user --name john\" :{ \"username\" : \"john\" } } } A sample response { \"get-users\" :{ \"user --name ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user --name john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"user --name john\" { \"msg\" : \"Updated Successfully\" } } } Without alias and with a pe block. A sample query { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , ] }, \"GET:data-john:pe\" :{ \"user --name john\" :[ \"username\" , \"email\" ] }, \"PUT:update-user-john\" : { \"user --name john\" :{ \"username\" : \"john\" }, \"after\" : \"data-john\" } } A sample response { \"get-users\" :{ \"user --name ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user --name john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"user --name john\" { \"msg\" : \"Updated Successfully\" }, \"after\" :{ \"user --name john\" :{ \"username\" : \"johnny\" , \"email\" : \"johnnys@example.com\" } } } } With aliases A sample query { \"GET:get-users\" :{ \"user --name ad | user-ad\" :[ \"username\" , \"email\" ], \"user --name john | user-john\" :[ \"username\" , ] }, \"PUT:update-user-john\" : { \"user --name john | update-john\" :{ \"username\" : \"john\" } } } A sample response { \"get-users\" :{ \"user-ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user-john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"update-john\" { \"msg\" : \"Updated Successfully\" } } }","title":"Response of a loafang query"},{"location":"loafang-response/#without-alias","text":"A sample query { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , ] }, \"PUT:update-user-john\" : { \"user --name john\" :{ \"username\" : \"john\" } } } A sample response { \"get-users\" :{ \"user --name ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user --name john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"user --name john\" { \"msg\" : \"Updated Successfully\" } } }","title":"Without alias"},{"location":"loafang-response/#without-alias-and-with-a-pe-block","text":"A sample query { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , ] }, \"GET:data-john:pe\" :{ \"user --name john\" :[ \"username\" , \"email\" ] }, \"PUT:update-user-john\" : { \"user --name john\" :{ \"username\" : \"john\" }, \"after\" : \"data-john\" } } A sample response { \"get-users\" :{ \"user --name ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user --name john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"user --name john\" { \"msg\" : \"Updated Successfully\" }, \"after\" :{ \"user --name john\" :{ \"username\" : \"johnny\" , \"email\" : \"johnnys@example.com\" } } } }","title":"Without alias and with a pe block."},{"location":"loafang-response/#with-aliases","text":"A sample query { \"GET:get-users\" :{ \"user --name ad | user-ad\" :[ \"username\" , \"email\" ], \"user --name john | user-john\" :[ \"username\" , ] }, \"PUT:update-user-john\" : { \"user --name john | update-john\" :{ \"username\" : \"john\" } } } A sample response { \"get-users\" :{ \"user-ad\" : { \"username\" : \"adnyx\" , \"email\" : \"adnyx@example.com\" }, \"user-john\" : { \"username\" : \"johnny\" } }, \"update-user-john\" :{ \"update-john\" { \"msg\" : \"Updated Successfully\" } } }","title":"With aliases"},{"location":"query-parts/","text":"A sample query This is what a sample loafang query looks like { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , \"email\" ] }, \"GET:get-user-fred:pe\" : { \"user --name fred\" :[ \"username\" , \"email\" ] }, \"PUT:update-user-fred\" : { \"user --name fred\" :{ \"username\" : \"fredmy\" }, \"after\" : \"get-user-fred\" } } The execution block. \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , \"email\" ] }, This is what's called as a Execution block. And a loafang query is made by stacking together a bunch of these Execution Blocks. Parts of an execution block The header GET : ge t - users This is the header of an execution block and is made up of three parts. The request type. ( GET , POST , PUT , DELETE , PATCH ) A unique identification string for the execution block And a block property key(Optional) The three parts are arranged in the following order METHOD:ID:PROPERTY_KEY The ID must be unique among all the execution blocks in a given loafang query. A property key can completely change the behavior of an execution block. Currently there is only one property key that is pe . The pe key will skip the execution of the given block The Body The body of an execution block is made up of all the queries that needs to be executed. The request methods ( GET , POST , ...) of each query will be the one specified in the header of the execution block. Parts of a query. The query has two parts, the args (the head and parameters) and the content of the query. \"user --name john\" : [ \"username\" , \"email\" ] This is a sample query inside an execution block. Here, user is the head of the query or where the query needs to executed, this can be a database name or anything like that. --name john is the parameter to the query. These can be parameter to filter the head. [\"username\", \"email\"] These are the content of the query, these can be the fields that you wish to get from the database with the specified parameters. The contents of the query must be a list for GET and DELETE queries and must be a dict / JS object for PUT , POST , and PATCH . Query Aliases In the end response that will be generated by loafang the key of the an executed query in a block will be the query it self. In order to make it a bit easier for a developer to go through the response, you can add aliases to your query. { \"GET:get-users\" :{ \"user --name ad | user-ad\" :[ \"username\" , \"email\" ], \"user --name john | user-john\" :[ \"username\" , \"email\" ] } } Anything after the pipe ( | ) is considered as an alias to the query. No to queries in a block can have the same alias but two queries in two different blocks can have the same alias name. Click Here to see how aliases affect the response. The after key. The after key in an execution block specifies another execution block that needs to executed after the current block has done executing. This can be used to retrieve data after a POST request has been made. The after key can only point to an execution block that has pe as it's property key. An execution block that has pe as it's property key cannot have an after key.","title":"Parts of a loafang query"},{"location":"query-parts/#a-sample-query","text":"This is what a sample loafang query looks like { \"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , \"email\" ] }, \"GET:get-user-fred:pe\" : { \"user --name fred\" :[ \"username\" , \"email\" ] }, \"PUT:update-user-fred\" : { \"user --name fred\" :{ \"username\" : \"fredmy\" }, \"after\" : \"get-user-fred\" } }","title":"A sample query"},{"location":"query-parts/#the-execution-block","text":"\"GET:get-users\" :{ \"user --name ad\" :[ \"username\" , \"email\" ], \"user --name john\" :[ \"username\" , \"email\" ] }, This is what's called as a Execution block. And a loafang query is made by stacking together a bunch of these Execution Blocks.","title":"The execution block."},{"location":"query-parts/#parts-of-an-execution-block","text":"","title":"Parts of an execution block"},{"location":"query-parts/#the-header","text":"GET : ge t - users This is the header of an execution block and is made up of three parts. The request type. ( GET , POST , PUT , DELETE , PATCH ) A unique identification string for the execution block And a block property key(Optional) The three parts are arranged in the following order METHOD:ID:PROPERTY_KEY The ID must be unique among all the execution blocks in a given loafang query. A property key can completely change the behavior of an execution block. Currently there is only one property key that is pe . The pe key will skip the execution of the given block","title":"The header"},{"location":"query-parts/#the-body","text":"The body of an execution block is made up of all the queries that needs to be executed. The request methods ( GET , POST , ...) of each query will be the one specified in the header of the execution block.","title":"The Body"},{"location":"query-parts/#parts-of-a-query","text":"The query has two parts, the args (the head and parameters) and the content of the query. \"user --name john\" : [ \"username\" , \"email\" ] This is a sample query inside an execution block. Here, user is the head of the query or where the query needs to executed, this can be a database name or anything like that. --name john is the parameter to the query. These can be parameter to filter the head. [\"username\", \"email\"] These are the content of the query, these can be the fields that you wish to get from the database with the specified parameters. The contents of the query must be a list for GET and DELETE queries and must be a dict / JS object for PUT , POST , and PATCH .","title":"Parts of a query."},{"location":"query-parts/#query-aliases","text":"In the end response that will be generated by loafang the key of the an executed query in a block will be the query it self. In order to make it a bit easier for a developer to go through the response, you can add aliases to your query. { \"GET:get-users\" :{ \"user --name ad | user-ad\" :[ \"username\" , \"email\" ], \"user --name john | user-john\" :[ \"username\" , \"email\" ] } } Anything after the pipe ( | ) is considered as an alias to the query. No to queries in a block can have the same alias but two queries in two different blocks can have the same alias name. Click Here to see how aliases affect the response.","title":"Query Aliases"},{"location":"query-parts/#the-after-key","text":"The after key in an execution block specifies another execution block that needs to executed after the current block has done executing. This can be used to retrieve data after a POST request has been made. The after key can only point to an execution block that has pe as it's property key. An execution block that has pe as it's property key cannot have an after key.","title":"The after key."}]}